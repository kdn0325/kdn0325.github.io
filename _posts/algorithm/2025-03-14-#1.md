---
title: "[알고리즘] 원시 타입 알아보기"

categories: algorithm

comments: true
tags:
  - cs
  - 알고리즘
  - 시간복잡도
  - 자료구조
  - 원시 타입
  - 참조 타입

date: 2025-03-14
last_modified_at: 2025-03-14
---

---

<!-- prettier-ignore -->
* this ordered seed list will be replaced by the toc 
{:toc}

## 1. 원시 타입

- 원시타입 - number, string , boolean
- 참조타입 - object

---

### 숫자 타입

```jsx
console.log(typeof 10); // number
console.log(typeof -5.5); // number
console.log(typeof 3.14); // number
console.log(typeof Infinity); // number
console.log(typeof NaN); // number (Not a Number 잘못된 연산 결과)
```

```jsx
let a = 13;
let b = 4;
```

```jsx
// 연산자
console.log(a + b); // 17
console.log(a - b); // 9
console.log(a * b); // 52
console.log(a / b); // 3.25
console.log(a % b); // 1 ( 모듈러 연산 : 나머지 구하기 )
console.log(-a); // -13 ( 단항 연산자 )
```

```jsx
// 빌트인 함수
console.log(Math.abs(-a)); // 13 ( 절대값 )
console.log(Math.ceil(a / b)); // 4 ( 올림 )
console.log(Math.floor(a / b)); // 3 ( 내림 )
console.log(Math.pow(a, b)); // 28561 ( 거듭제곱 )
console.log(Math.round(a / b)); // 3 ( 반올림 )
console.log(Math.sqrt(a)); // 3.605551275463989 ( 제곱근 )
console.log(Math.trunc(-a / b)); // -3 ( 버림 )
```

```jsx
//숫자 타입 비교 연산
console.log(a == b); // false
console.log(a != b); // true
console.log(a < b); // false
console.log(a > b); // true
console.log(a <= b); // false
console.log(a >= b); // true
```

```jsx
//숫자 타입 비트 연산
console.log(a & b); // 4 ( AND )
console.log(a | b); // 13 ( OR )
console.log(a ^ b); // 9 ( XOR )
console.log(~a); // -14 ( NOT )
console.log(a << 2); // 52 ( 왼쪽 시프트 : a에 2^2를 곱한 몫 )
console.log(a >> 1); // 3 ( 오른쪽 시프트 : a를 2^1로 나눈 몫 )
```

```jsx
//숫자 타입 논리 연산
console.log(a && b); // 4 ( AND )
console.log(a || b); // 13 ( OR )
console.log(!a); // false ( NOT )
```

```jsx
//숫자 타입 예외 상황
console.log(a / 0); // Infinity
console.log(a % 0); // NaN
console.log(a / "string"); // NaN
console.log(a % "string"); // NaN
console.log(a / null); // NaN
console.log(a % null); // NaN
console.log(a / undefined); // NaN
console.log(a % undefined); // NaN */
```

**부동 소수 문제 - 자바스크립트는 부동소수점 데이터를 이진법으로 표현하기 때문에 오차가 발생함 (엡실론)**

```jsx
// 앱실론 출력해보기
console.log(Number.EPSILON); // 2.220446049250313e-16
let a = 0.1 + 0.1 + 0.1;
let b = 0.3;
console.log(a - b); // 5.551115123125783e-17

if (Math.abs(a - b) < Number.EPSILON) {
  console.log("a,b가 같음"); // true
} else {
  console.log("a,b가 다름");
}
```

### 문자 타입

```jsx
let a = "hello";
let b = " world";
console.log(a + b); // 문자열 더하기 (hello world)
console.log(a + 126); // 문자열과 숫자 더하기 (hello126)
console.log(a + true); // 문자열과 불리언 더하기 (hellotrue)
```

```jsx
// 문자열 타입 빌트인 메서드
const a = "hello, world!";
console.log(a.length); // 13 (문자열 길이)
console.log(a.split(",")); // ["hello", " world!"] (문자열 기준으로 나누기)
console.log(a.startsWith("hello")); // true (문자열로 시작하는지)
console.log(a.endsWith("world!")); // true (문자열로 끝나는지)
console.log(a.includes("llo")); // true (문자열 포함하는지)
console.log(a.indexOf("world")); // 7 (문자열 시작 위치)
console.log(a.lastIndexOf("l")); // 10 (문자열 끝 위치)
```

```jsx
// // 특정 문자열 대체
console.log(a.replace("world", "javascript")); // hello, javascript!
console.log(a.toUpperCase()); // HELLO, WORLD! (대문자로 변환)
console.log(a.toLowerCase()); // hello, world! (소문자로 변환)
console.log(a.trim()); // hello, world! ( 양쪽 공백 제거)
console.log(a.concat("!!")); // hello, world!!! (문자열 연결)
```

```jsx
// 이외 타입
console.log(typeof true); // boolean
console.log(typeof 2147383647n); // bigint
console.log(typeof undefined); // undefined
console.log(typeof null); // object - 버그임; null은 object로 나옴
console.log(typeof Symbol("symbol")); // symbol
```

### 불리언 타입

```jsx
// boolean 타입
console.log(typeof true); // boolean
console.log(typeof false); // boolean
```

### bigint 타입 - 큰수를 다룰 때 사용, bigint를 사용하면 제대로 연산 가능 (뒤에 n을 붙이거나 BigInt()함수 사용)

```jsx
// bigint 타입 - 큰수를 다룰 때 사용, bigint를 사용하면 제대로 연산 가능 (뒤에 n을 붙이거나 BigInt()함수 사용)
console.log(10000000000000000000 - 123456); // 9999999999876544
console.log(10000000000000000000n - BigInt(123456)); // 9999999999876544n
console.log(10000000000000000000n - 123456); // 에러
```

### undefined / null 타입 - undefined : 초기화 타입 , null은 의도적으로 비어있다는걸 표현할 때
