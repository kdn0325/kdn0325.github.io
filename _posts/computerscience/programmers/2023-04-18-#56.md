---
title: "[프로그래머스] A로 B 만들기"

categories: computerscience
sitemap:
  changefreq: daily
  priority: 1.0
comments: true

tags:
  - programmers
  - Code Refactoring
  - 참고 할 만한 다른 사람의 코드
  - 코딩 기초 트레이닝
  - 프로그래머스
  - 코딩테스트 연습
  - JavaScript
  - A로 B 만들기
  - js A로 B 만들기

author_profile: true
toc: true
toc_sticky: true

date: 2023-04-18
last_modified_at: 2023-11-21
---

---

### 문제 설명

문자열 `before`와 `after`가 매개변수로 주어질 때, `before`의 순서를 바꾸어 `after`를 만들 수 있으면 1을, 만들 수 없으면 0을 return 하도록 solution 함수를 완성해보세요.

---

### 제한사항

- 0 < `before`의 길이 == `after`의 길이 < 1,000
- `before`와 `after`는 모두 소문자로 이루어져 있습니다.

---

### 입출력 예

| before  | after   | result |
| ------- | ------- | ------ |
| "olleh" | "hello" | 1      |
| "allpe" | "apple" | 0      |

---

### 입출력 예 설명

입출력 예 #1

- "olleh"의 순서를 바꾸면 "hello"를 만들 수 있습니다.

입출력 예 #2

- "allpe"의 순서를 바꿔도 "apple"을 만들 수 없습니다.

---

### 나의 풀이

```jsx
function solution(before, after) {
  var answer =
    before.split("").sort().join("") === after.split("").sort().join("")
      ? 1
      : 0;
  return answer;
}
```

---

### 나의 두번째 풀이(Code Refactoring)

```jsx
function solution(before, after) {
  return [...before].sort().join() === [...after].sort().join() ? 1 : 0;
}

// 1. sort로 알파벳 순으로 정렬해준다
// 2. 그냥 sort만 해서 비교하면 배열의 주솟값은 다르지만 배열의 데이터값은 같게 된다.
// 3. 그래서 join을 사용하여 문자열의 데이터값을 비교
```

---

### 참고 할 만한 다른 사람의 코드

```jsx
function solution(before, after) {
  const obj = {};
  for (let i = 0; i < before.length; i++) {
    obj[before[i]] = obj[before[i]] ? obj[before[i]] + 1 : 1;
  }
  for (let i = 0; i < after.length; i++) {
    console.log(obj[after[i]]);
    if (!obj[after[i]]) return 0;
    else obj[after[i]]--;
  }
  return 1;
}
```
